# 第三章 · 第二题

3.2 设A=<x1，x2，…，xn\>是n个不等的整数构成的序列，A的一个单调递增子序列是序列<，，…，>，使得i1<i2<…<ik，且<<…<，，子序列<，，…，>的长度是含有的整数个数k。例如A=<1，5，3，8，10，6，4，9>，它的长为4的递增子序列是：<1，5，8，10>，<1，5，8，9>，…，设计一个算法求A的一个最长的单调递增子序列，分析算法的时间复杂度。设算法的输入实例是A=<2，8，4，-4，5，9，11>，给出算法的计算过程和最后的解。

使用动态规划设计技术。对于i=1，2，…，n，考虑以作为最后项的最长递增子序列的长度。如果在项前面存在，那么;否则。因此

在计算时，用记录取得最大值时的的值;如果不存在这样的，令。这个记录用于追踪解。所求的最长递增子序列的长度是

对每个，需要检索比小的所有的，需要O(n)时间，的取值有种，于是算法时间复杂度是W(n)=O(n2)。

对于给定的实例A=<2，8，4，-4，5，9，11>，具体的计算过程如下：

C\[1\]=1

C\[2\]=max{C\[1\]+1}=2， k\[2\]=1

C\[3\]=max{C\[1\]+1}=2， k\[3\]=1

C\[4\]=1， k\[4\]=0

C\[5\]=max{C\[1\]+1，C\[3\]+1，C\[4\]+1}=3， k\[5\]=3

C\[6\]=max{C\[1\]+1，C\[2\]+1，C\[3\]+1，C\[4\]+1，C\[5\]+1}=4， k\[6\]=5

C\[7\]=max{C\[1\]+1，C\[2\]+1，C\[3\]+1，C\[4\]+1，C\[5\]+1，C\[6\]+1}=5， k\[7\]=6

在C\[1\]，C\[2\]，…，C\[7\]中，C\[7\]=5是最大值，这意味着A的第7项x7=11是最长递增子序列的最后项，长度是5。子序列的构造从后向前进行，开始是11，追踪过程是：

k\[7\]=6，x6\=9，

k\[6\]=5，x5\=5，

k\[5\]=3，x3\=4，

k\[3\]=1，x1\=2于是得到解是：<2，4，5，9，11>，长度是5。本题可以有多个解。

#include <iostream>

#include <string.h>

using namespace std;

int main()

{

int n;

while(cin>>n)

{

int x\[n+1\]={0}，C\[n+1\]={0}，k\[n+1\]={0};

for(int i=1;i<=n;i++)

cin>>x\[i\];

C\[1\]=1;

for(int i=2;i<=n;i++)

{

C\[i\]=1;

for(int j=i-1;j>=1;j--)

{

if(x\[j\]<x\[i\])

{

int t=C\[j\]+1;

if(t>C\[i\])

{

C\[i\]=t;

k\[i\]=j;

}

}

}

}

int t=C\[1\]，j;

for(int i=2;i<=n;i++)

{

if(C\[i\]>t)

{

t=C\[i\];

j=i;

}

}

int r\[n+1\]={0};

r\[0\]=C\[j\];

r\[1\]=x\[j\];

j=k\[j\];

int i=2;

while(j>0)

{

r\[i\]=x\[j\];

i++;

j=k\[j\];

}

for(int j=i-1;j>1;j--)

printf("%d，"，r\[j\]);

printf("%d\\n%d"，r\[1\]，r\[0\]);

}

return 0;

}

/\*

7

2 8 4 -4 5 9 11

8

1 5 3 8 10 6 4 9

\*/
