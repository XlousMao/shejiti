# 第二章：分治策略 · 第一题

### 2.1 设输入是n个数的数组A\[1..n\]，下述排序算法是插入排序。

算法 InsertSort(A)

1.for i←2 to n do

2\. x←A\[i\]

3\. j←i-1

4\. while j>0 and A\[j\]>x do

5\. A\[j+1\]←A\[j\]

6\. j←j-1

7\. A\[j+1\]←x

改进上述算法，在插入元素A\[i\]时用二分查找代替顺序查找，将这个算法记作ModInsertSort，给出该算法的伪码，并估计算法在最坏情况下的时间复杂度。

算法的伪码是：

ModInsertSort(A，1，n)

1.  for i←2 to n do

2\. x←A\[i\]

3\. k←BinarySearch(A，1，i-1，x)//在A\[1..i-1\]中二分查找x应该插入的位置k

4\. for j=i-1 downto k

5\. A\[j+1\]←A\[j\]

6\. A\[k\]←x

for循环执行n-1次，在i-1规模的数组二分查找的比较次数为log(i-1)+1，因此总的比较次数为

#include <iostream>

using namespace std;

int n,A\[14\];

int BinarySearch(int l,int r,int x)

{

int m;

if(l<=r)

{

m=(l+r)/2;

if(A\[m\]==x)

return m;

if(A\[m\]>x)

return BinarySearch(l,m-1,x);

return BinarySearch(m+1,r,x);

}

return l;

}

void InsertSort()

{

int i,j,x;

for(i=2;i<=n;i++)

{

x=A\[i\];

j=i-1;

while(j>0 && A\[j\]>x)

{

A\[j+1\]=A\[j\];

j=j-1;

}

A\[j+1\]=x;

}

}

void ModInsertSort()

{

int i,j,k,x;

for(i=2;i<=n;i++)

{

x=A\[i\];

k=BinarySearch(1,i-1,x);

for(j=i-1;j>=k;j--)

A\[j+1\]=A\[j\];

A\[k\]=x;

}

}

int main()

{

int i;

while(cin>>n)

{

for(i=1;i<=n;i++)

cin>>A\[i\];

InsertSort();

//ModInsertSort();

for(i=1;i<n;i++)

cout<<A\[i\]<<",";

cout<<A\[n\]<<endl;

}

return 0;

}

/\*

13

27 99 0 8 13 64 86 16 7 10 88 25 90

////////////////////////////////////

0,7,8,10,13,16,25,27,64,86,88,90,99

\*/
