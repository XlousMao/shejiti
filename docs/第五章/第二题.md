# 第五章 · 第二题

5.2 最小重量机器设计问题。某设备需要4种配件，每种1件。有3个供应商提供这些配件，表5.1给出相关的价格和每种配件的重量。

表5.1 产品和供应商信息表

零件编号

供应商1

供应商2

供应商3

价格

重量

价格

重量

价格

重量

1

10

5

8

6

12

4

2

20

8

21

10

30

5

3

40

5

42

4

30

10

4

30

20

60

10

45

15

从中选择4种配件，使得总价值不超过120，总重量最轻。

4 3 120

10 8 12

20 21 30

40 42 30

30 60 45

5 6 4

8 10 5

5 4 10

20 10 15

按照价格从小到大对零件排序（回溯法可以；？？如果是分支限界，就要按wi/vi）。设解向量为<x1，x2，…，xn\>，xi\=j表示第i号零件由j号供应商供货。1≤xj≤m。结点<x1，x2，…，xk\>表示已经选择了前k号零件的供应商，正在处理第k+1号零件。

约束条件:选择下一个零件总价格不超过120，才选。

代价函数:（分支限界？？）

其中表示第l个供应商j号零件的重量。

解:对实例<3，1，2，3>，总重量为31，价值为119。

#include <stdio.h>

int n=4,m=3,d=120;

int w\[5\]\[4\]={

0,0,0,0,

0,5,6,4,

0,8,10,5,

0,5,4,10,

0,20,10,15

};

int v\[5\]\[4\]={

0,0,0,0,

0,10,8,12,

0,20,21,30,

0,40,42,30,

0,30,60,45

};

int bestw=0x3f3f3f3f,bestx\[5\],x\[5\],cw=0,cv=0;

void Backtrack(int t)

{

if(t>n)

{

bestw=cw;

for(int i=1;i<=n;i++)

bestx\[i\]=x\[i\];

}//if

for(int i=1;i<=m;i++)

{

if(cv+v\[t\]\[i\]<=d && cw+w\[t\]\[i\]<bestw)

{

x\[t\]=i;

cv+=v\[t\]\[i\];

cw+=w\[t\]\[i\];

Backtrack(t+1);

cw-=w\[t\]\[i\];

cv-=v\[t\]\[i\];

}//if

}//for

}//Backtrace

int main()

{

Backtrack(1);

printf("%d\\n<",bestw);

for(int i=1;i<n;i++)

printf("%d,",bestx\[i\]);

printf("%d>\\n",bestx\[n\]);

return 0;

}//main

/\*

31

<3,1,2,3>

\*/

/\*

3 3 4

1 2 3

3 2 1

2 2 2

1 2 3

3 2 1

2 2 2

////////////

4

1 3 1

\*/

999999999999999999999

#include <iostream>

#include <vector>

#include <queue>

using namespace std;

struct node

{

int w,c,i,j; //当獭?前°重?量?和í,当獭?前°花¨费?和í,零?件t序ò号?（辍?也?是?层?数簓）?,厂§商Θ?序ò号?

node \*parent; //父?母?节ú点?

//用?于?赋3值μ

node(int w,int c,int i,int j,node \*p):w(w),c(c),i(i),j(j),parent(p)

{

}

//重?载?运?算?符?<，?用?于?优?先è队ó列中D排?序ò优?先è级?

bool operator<(const node & a) const

{

if(w!=a.w)

return w>a.w; //w大洙?，?则ò优?先è级?高?

else if(i!=a.i)

return a.i>i; //w相à同?则ò比括?较?层?级?，?倾?向ò于?层?数簓更ü深?的?节ú点?，?这a样ù可é以?更ü快ì到?达?叶?节ú点?

else

return j>a.j;//前°二t者?均ù相à同?，?按恪?厂§商Θ?序ò号?排?

}

};

class MinWeight

{

private:

int n,m,d; //零?件t数簓,厂§商Θ?数簓,成é本?约?束?

int bestw; //最?优?重?量?

vector<int> lb; //下?界?数簓组哩?lb\[i\]表括?示?第台瞚到?n零?件t最?小?的?重?量?和í

vector<int> bestx; //解a

vector<vector<int> > w,c; //重?量?,价?值μ数簓组哩?

public:

MinWeight()

{

cin>>n>>m>>d;

bestx.resize(n);

w.resize(n);

c.resize(n);

for(int i=0;i<n;i++)

{

w\[i\].resize(m);

c\[i\].resize(m);

}//for

for(int i=0;i<n;i++)

for(int j=0;j<m;j++)

cin>>c\[i\]\[j\];

//lb的?初?始?化ˉ，?输?入?w时骸?顺3便?计?算?

lb.resize(n);

for(int i=0;i<n;i++)

{

int minw=INT\_MAX;

for(int j=0;j<m;j++)

{

cin>>w\[i\]\[j\];

//记?录?下?第台瞚个?零?件t的?最?小?重?量?

if(w\[i\]\[j\]<minw)

minw=w\[i\]\[j\];

}//for

//初?始?化ˉlb数簓组哩?

lb\[i\]=minw;

}//for

//计?算?lb数簓组哩?

for(int i=n-2;i>=0;i--)

lb\[i\]=lb\[i+1\]+lb\[i\];

bestw=INT\_MAX; //初?始?化ˉ最?小?重?量?

}//MinWeight

void BranchBound()

{

priority\_queue<node> q;//小?根ù堆?

node root(0,0,-1,0,NULL);//优?先è队ó列初?始?化ˉ,放?入?根ù节ú点?,w,c,i,j,parent

q.push(root);

//分?枝|限T界?的?最?小?代洙?价?搜?索÷

while(!q.empty())

{

node \*curNode=new node(q.top()); //为a每?个?访?问ê过y的?节ú点?申Θ?请?内ú存?，?以?便?后ó续?求ó解a路·径?

q.pop();

//到?达?叶?子哩?节ú点?

if(curNode->i==n-1)

{

//满ú足?剪?枝|函ˉ数簓和í约?束?条?件t

if(curNode->w<bestw && curNode->c<=d)

{

//最?小?重?量?更ü新?

bestw=curNode->w;

//最?优?路·径?更ü新?

for(node \*t=curNode;t->i!=-1;t=t->parent)

bestx\[t->i\]=t->j+1;//+1是?因皑?为aj从洙?开a始?计?数簓

}//if

}//if

else

{

//未′到?达?叶?节ú点?,子哩?节ú点?加ó入?优?先è队ó列

for(int j=0;j<m;j++)

{

//临ⅷ?时骸?变?量?不?存?储洹?

node child(curNode->w+w\[curNode->i+1\]\[j\],curNode->c+c\[curNode->i+1\]\[j\],curNode->i+1,j,curNode);

//约?束?条?件t与?限T界?条?件t，?不?满ú足?的?被?忽?略?剪?枝|

if(child.c<=d && LB(child)<bestw)

q.push(child);

}//for

}//else

}//while

//输?出?结á果?

if(bestw==INT\_MAX)

{

cout<<"无T法ぁ?满ú足?成é本?约?束?条?件t"<<endl;

return;

}

cout<<bestw<<endl;

cout<<"<";

for(int i=0;i<n-1;i++)

cout<<bestx\[i\]<<",";

cout<<bestx\[n-1\]<<">"<<endl;

}

private:

//计?算?节ú点?分?枝|的?重?量?下?界?

int LB(node x)

{

if(x.i==n-1)

return x.w;

return x.w+lb\[x.i+1\];

}//LB

};//MinWeight

int main()

{

MinWeight ex;

ex.BranchBound();

}

/\*

4 3 120

10 8 12

20 21 30

40 42 30

30 60 45

5 6 4

8 10 5

5 4 10

20 10 15

//////////////////

31

<3,1,2,3>

\*/
