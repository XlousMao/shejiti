# 第四章 · 第二题

**4.2 有n个底面为长方形的物品需要租用库房存放。如果每个物品都必须放在地面上，且所有物品的底面宽度都等于库房的宽度，那么第i个物品占用库房面积大小只需要用它的底面长度li来表示，i=1，2，…，n。设库房总长度是L，且![](data:image/x-wmf;base64,183GmgAAAAAAABAGrwTsCQAAAABCXAEACQAAA5EBAAACABwAAAAAAAUAAAAJAgAAAAAFAAAAAgEBAAAABQAAAAEC////AAUAAAAuARgAAAAFAAAACwIAAAAABQAAAAwCQASABRIAAAAmBg8AGgD/////AAAQAAAAwP///7H///9ABQAA8QMAAAsAAAAmBg8ADABNYXRoVHlwZQAA4AAcAAAA+wKA/gAAAAAAAJABAQAAAAQCABBUaW1lcyBOZXcgUm9tYW4A/v///zDdGQBcJK91QAAAAAQAAAAtAQAACAAAADIKgAJdBAEAAABMvggAAAAyCoAC+QEBAAAAbAAcAAAA+wIg/wAAAAAAAJABAQAAAAQCABBUaW1lcyBOZXcgUm9tYW4A/v///zDdGQBcJK91QAAAAAQAAAAtAQEABAAAAPABAAAIAAAAMgr6AMsAAQAAAG4ACAAAADIK7wNzAAEAAABpPhwAAAD7AoD+AAAAAAAAkAEAAAACBAIAEFN5bWJvbAC7AAAKAECY/AT+////MN0ZAFwkr3VAAAAABAAAAC0BAAAEAAAA8AEBAAgAAAAyCoACJQMBAAAAPr4cAAAA+wLA/QAAAAAAAJABAAAAAgQCABBTeW1ib2wAjwAACgBgmPwE/v///zDdGQBcJK91QAAAAAQAAAAtAQEABAAAAPABAAAIAAAAMgrZAjcAAQAAAOU+HAAAAPsCIP8AAAAAAACQAQAAAAIEAgAQU3ltYm9sALwAAAoAIJn8BP7///8w3RkAXCSvdUAAAAAEAAAALQEAAAQAAADwAQEACAAAADIK7wPDAAEAAAA9ABwAAAD7AiD/AAAAAAAAkAEAAAAABAIAEFRpbWVzIE5ldyBSb21hbgD+////MN0ZAFwkr3VAAAAABAAAAC0BAQAEAAAA8AEAAAgAAAAyCu8DMgEBAAAAMQAIAAAAMgrgAmMCAQAAAGk9CgAAACYGDwAKAP////8BAAAAAAAcAAAA+wIQAAcAAAAAALwCAAAAhgECAiJTeXN0ZW0AR7QAigUAAAoAmjFmR5oxZke0AIoFkN4ZAAQAAAAtAQAABAAAAPABAQADAAAAAAA=)。如果要求放入库房的物品个数最多，选用哪种算法设计技术?简述算法的设计思想，证明算法的正确性，并估计算法最坏情况下的时间复杂度。**

使用贪心法。

贪心策略：按照底面长度从小到大对物品排序，从标号小的物品开始依次装入库房，直到某个物品装不下为止。（短者优先，最优装载）

命题4.2 对任何输入，把物品按照从小到大的顺序装入将得到最优解。

证 使用交换论证的方法。令物品集合为S={1，2，…，n}。假设A={i1，i2，…，ik}是一个最优解，不妨设i1<i2<…<ik。与上述算法的解B={1，2，…}比较，假若i1\=1，i2\=2，…，ij-1\=j-1，ij≠j，那么把ij替换成j，即

A'=(A-{ij}U{j}

由于ij\>j，其底面长度不小于j的底面长度，A'是一个可行解；且由于|A'|=|A|，A'也是一个最优解。如上不断替换A，至多经过n-1次就可以得到B，从而证明B是一个最优解。

算法最坏情况下的时间复杂度是O(nlogn)。

#include <iostream>

#include <algorithm>

#include <queue>

using namespace std;

typedef struct{

int id,l;

}G;

bool cmp(G x,G y)

{

return x.l<y.l;

}

int main()

{

int n,L,l\[100\],i,s;

G N\[100\];

queue<int> q;

while(cin>>n>>L)

{

for(i=1;i<=n;i++)

{

N\[i\].id=i;

cin>>N\[i\].l;

}//for

sort(N+1,N+n+1,cmp);

for(i=1;i<=n;i++)

l\[i\]=N\[i\].l;

q.push(1);

s=l\[1\];

for(i=2;i<=n;i++)

if(s+l\[i\]<=L)

{

s+=l\[i\];

q.push(i);

}//if

s=q.size();

cout<<s<<endl;

for(i=1;i<s;i++)

{

cout<<N\[q.front()\].id<<",";

q.pop();

}//for

cout<<N\[q.front()\].id<<endl;

q.pop();

}//while

return 0;

}

/\*

5 11

4 6 2 8 5

/////////

3

3,1,5

\*/

/\*

8 100

60 70 80 90 30 40 10 20

4

7,8,5,6

\*/
