# 第四章 · 第三题

**4.3 设有一条边远山区的道路AB，沿着道路AB分布着n所房子。这些房子到A的距离分别是d1，d2，…，dn(d1<d2<…<dn)。为了给所有房子的用户提供移动电话服务，需要在这条道路上设置一些基站。为了保证通信质量，每所房子应该位于距离某个基站的4千米范围之内。设计一个算法找到基站的位置，并且使得基站总数达到最少。用文字说明算法的主要设计思想，给出算法的伪码描述，证明算法的正确性并给出算法最坏情况下的时间复杂度函数。**

使用贪心法．令a1，a2，…表示基站的位置。

贪心策略：首先令a1\=d1+4。对d2，d3，…，dn依次检查，找到下一个不能被该基站覆盖的房子。如果dk≤a1+4但dk+1\>a1+4，那么第k+1个房子不能被基站覆盖，于是取a2\=dk+1+4作为下一个基站的位置。照此下去，直到检查完dn为止。

算法的伪码如下：

Location

输入：距离d1，d2，…，dn的数组d\[1..n\]，满足d\[1\]<d\[2\]<…<d\[n\]

输出：基站位置的数组a

1.a\[1\]←d\[1\]+4

2.k←1

3.for j←2 to n

4\. if d\[j\]>a\[k\]+4

5\. then k←k+1

6\. a\[k\]←d\[j\]+4

7.return a

算法正确性证明使用归纳法。

命题4.3 对任何正整数k，存在最优解包含算法前k步选择的基站位置。

证

k=1，存在最优解包含a\[1\]。

若不然，有最优解OPT，其第一个位置是b\[1\]，b\[1\]≠a\[1\]，那么d1\-4≤b\[1\]<d1+4=a\[1\]。b\[1\]覆盖的是距离在\[d1，b\[1\]+4\]之间的房子。a\[1\]覆盖的是距离在\[d1，a\[1\]+4\]的房子。因为b\[1\]<a\[1\]，b\[1\]覆盖的房子都在a\[1\]覆盖的区域内，用a\[1\]替换b\[1\]，得到的仍旧是最优解。

假设对于k，存在最优解A包含算法前k步选择的基站位置，即

A={a\[1\]，a\[2\]，…，a\[k\]}UB

其中a\[1\]，a\[2\]，…，a\[k\]覆盖了距离d1，d2…，dj的房子。那么，B是关于L={dj+1，dj+2，…，dn}的最优解。否则，存在关于L的更优的解B\*，那么用B\*替换B就得到A\*，且|A\*|<|A|，与A的最优性矛盾。根据归纳基础，L有一个最优解B'={a\[k+1\]，…)，|B|=|B|。于是

A'={a\[1\]，a\[2\]，…，a\[k\]}UB'

\={a\[1\]，a\[2\]，…，a\[k\]，a\[k+1\]，…}

且|A'|=|Al，A'也是最优解。从而证明了命题对k+1也为真。根据归纳法，对任何正整数k命题都成立。

第3行的for循环运行O(n)次，循环体内操作为常数时间，因此算法最坏情况下的时间复杂度是O(n)。

#include <iostream>

using namespace std;

int main()

{

int n,d\[100\],a\[100\],i,j,k;

while(cin>>n)

{

for(i=1;i<=n;i++)

cin>>d\[i\];

a\[1\]=d\[1\]+4;

k=1;

for(j=2;j<=n;j++)

if(d\[j\]>a\[k\]+4)

{

k=k+1;

a\[k\]=d\[j\]+4;

}//if

for(i=1;i<k;i++)

cout<<a\[i\]<<",";

cout<<a\[k\]<<endl;

}//while

}//main

/\*

6

1 3 4 8 12 15

/////////////

5,16

\*/

/\*

5

3 7 10 12 18

////////////

7,16

\*/
